#!/usr/bin/env ruby

require 'json'
require 'fileutils'
require 'digest'
require 'net/http'
require 'cgi'
require 'securerandom'
require 'readline'
require 'base64'
require 'pathname'
require 'shellwords'
require 'singleton'

CONFIG_FILE=::File.expand_path("~/.metis.json")

def test_env?
  ENV['METIS_ENV'] == 'test'
end

class MetisConfig
  include Singleton

  def self.[](k)
    instance[k]
  end

  def config(config)
    @config = config
  end

  def [](k)
    @config[k]
  end
end

INITIAL_BLOB_SIZE = 2**10
MAX_BLOB_SIZE = 2**22;
ZERO_HASH = 'd41d8cd98f00b204e9800998ecf8427e'

class Upload
  attr_reader :file_path
  def initialize(file_path)
    @file_path = file_path

    @next_blob_size = [ file_size, INITIAL_BLOB_SIZE ].min
    @current_byte_position = 0
  end

  attr_accessor :next_blob_size

  def current_byte_position=(position)
    @current_byte_position = position
    @current_bytes = nil
    @current_byte_position
  end

  def current_byte_position
    @current_byte_position
  end

  def next_blob!
    self.current_byte_position = @current_byte_position + @next_blob_size

    @next_blob_size = [
        MAX_BLOB_SIZE,
        # in fact we should stop when we hit the end of the file
        file_size - current_byte_position
    ].min
  end

  def complete?
    @current_byte_position >= file_size
  end

  def next_blob_hash
    Digest::MD5.hexdigest(current_bytes)
  end

  def current_bytes
    @current_bytes ||= IO.binread(@file_path, @next_blob_size, @current_byte_position)
  end

  def file_size
    @file_size ||= ::File.size(@file_path)
  end
end

class MetisClient
  class Error < StandardError
  end
  def initialize(host, token)
    @host = host
    @token = token
  end

  def authorize_upload(project_name, bucket_name, file_path)
    response = json_post('/authorize/upload', project_name: project_name, bucket_name: bucket_name, file_path: file_path)

    raise MetisClient::Error, "Could not upload file to #{file_path}\n#{error(response)}" unless response.code == "200"

    return json_body(response)
  end

  def start_upload(upload_path, upload)
    response = json_post(upload_path,
      file_size: upload.file_size,
      action: 'start',
      next_blob_size: upload.next_blob_size,
      next_blob_hash: upload.next_blob_hash
    )

    raise MetisClient::Error, "Could not upload file #{upload.file_path}\n#{error(response)}" unless response.code == "200"

    json_body(response)
  end

  def blob_upload(upload_path, upload, blob)
    response = multipart_post(
      upload_path, [
        [ 'action', 'blob', ],
        [ 'blob_data', blob[:blob_data], {filename: 'blob'} ],
        [ 'next_blob_size', blob[:next_blob_size].to_s ],
        [ 'next_blob_hash', blob[:next_blob_hash].to_s ],
        [ 'current_byte_position', blob[:current_byte_position].to_s ]
      ]
    )

    raise MetisClient::Error, "Could not upload file #{upload.file_path}\n#{error(response)}" unless response.code == "200"
  end

  def create_folder(project_name, folder_path)
    response = json_post("/#{project_name}/folder/create/#{URI.encode(folder_path)}")
    raise MetisClient::Error, "Could not create folder #{folder_path}\n#{error(response)}" unless response.code == "200" || (response.code == "422" && error(response) == 'Folder exists')
  end

  def list_buckets(project_name)
    response = get("/#{project_name}/list")
    raise MetisClient::Error, "Could not list buckets for #{project_name}\n#{error(response)} #{response.code}" unless response.code == "200"
    return json_body(response)[:buckets]
  end

  def list_folder(project_name,folder_path)
    response = get("/#{project_name}/list/#{folder_path}")

    return nil if response.code == "404"
    raise MetisClient::Error, "Could not list folder #{folder_path}\n#{error(response)}" unless response.code == "200"
    return json_body(response)
  end

  def rename_folder(project_name,bucket_name,folder_path,new_folder_path)
    response = json_post("/#{project_name}/folder/rename/#{bucket_name}/#{URI.encode(folder_path)}", new_folder_path: new_folder_path)
    raise MetisClient::Error, "Could not rename folder #{folder_path}\n#{error(response)}" unless response.code == "200"
  end

  def rename_file(project_name,bucket_name,file_path,new_file_path)
    response = json_post("/#{project_name}/file/rename/#{bucket_name}/#{URI.encode(file_path)}", new_file_path: new_file_path)
    raise MetisClient::Error, "Could not rename file #{file_path}\n#{error(response)}" unless response.code == "200"
  end

  private

  def json_post(path, body={})
    post(path) do |req|
      req['Content-Type'] = 'application/json'
      req.body = body.to_json
    end
  end

  def multipart_post(path, body)
    post(path) do |req|
      req.set_form(body, 'multipart/form-data')
    end
  end

  def get(path, &block)
    request(path, Net::HTTP::Get, &block)
  end

  def post(path, &block)
    request(path, Net::HTTP::Post, &block)
  end

  def request(path, method)
    uri = URI.parse("https://#{@host}#{path}")
    https = Net::HTTP.new(uri.host,uri.port)
    https.use_ssl = true
    req = method.new(uri.request_uri)
    req['Authorization'] = "Etna #{@token}"
    cookie = CGI::Cookie.new(MetisConfig[:metis_uid_name], MetisConfig[:metis_uid])
    req['Cookie'] = cookie.to_s

    yield(req) if block_given?

    https.request(req)
  end

  def json_body(response)
    JSON.parse(response.body,symbolize_names: true)
  end

  def error(response)
    response['Content-Type'] == 'application/json' ? json_body(response)[:error] : response.body
  end
end

class MetisShell
  USAGE=<<EOT
Recursively upload files to a Metis folder
Usage: metis_client [metis://<path>]
EOT

  class Command
    def self.inherited(subclass)
      @command_list ||= []
      @command_list << subclass
    end

    def self.list
      @command_list
    end

    def self.command_name
      name.split(/::/).last
        .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
        .gsub(/([a-z\d])([A-Z])/, '\1_\2')
        .downcase
    end

    def initialize(shell)
      @shell = shell
    end

    def run(*args)
      raise "#{self.class.command_name} is not implemented!"
    end

    private

    def neat_display(files:[], folders:[])
      entries = [
        *files,
        *folders.map{|f| f+"/"}
      ].compact.sort

      return if entries.empty?

      rows, cols, col_widths = calculate_dimensions(entries)

      rows.times do |row|
        puts cols.times.map { |col| entries[ col * rows + row ]&.ljust(col_widths[col]) }.join('')
      end
    end

    def calculate_dimensions(entries)
      term_width = ENV['COLUMNS'].to_i
      min_column_width = 3
      max_columns = [term_width/min_column_width + 1, entries.size ].min
      max_columns.downto(1).each do |cols|
        rows, mod = entries.size.divmod(cols)

        if mod != 0
          next if (rows + 1) * (cols - 1) >= entries.size
          rows = rows + 1
        end

        col_widths = (0...cols).map do |col|
          width = (0...rows).map { |row| entries[col * rows + row]&.size }.compact.max
          (col < cols - 1) ? (width + 2) : (width)
        end

        next if col_widths.sum > term_width - 2

        return [ rows, cols, col_widths ]
      end
      return [ entries.size, 1, entries.map{0} ]
    end
  end

  class Mv < Command
    def run(path, new_path)
      raise ShellError, 'No project is selected' if !@shell.project_name

      path = @shell.relative_path(path)
      new_path = @shell.relative_path(new_path)

      name = ::File.basename(path)

      folder = @shell.client.list_folder(@shell.project_name, ::File.dirname(path))

      raise ShellError, "Invalid path #{path}" unless folder

      file = folder[:files].find do |f|
        f[:file_name] == name
      end

      if file
        bucket_name, file_path = path.split('/',2)
        bucket_name, new_file_path = new_path.split('/',2)
        @shell.client.rename_file(@shell.project_name, bucket_name, file_path, new_file_path)
        return
      end

      folder = folder[:folders].find do |f|
        f[:folder_name] == name
      end

      if folder
        bucket_name, folder_path = path.split('/',2)
        bucket_name, new_folder_path = new_path.split('/',2)
        @shell.client.rename_folder(@shell.project_name, bucket_name, folder_path, new_folder_path)
        return
      end
    end
  end

  class Ls < Command
    def run(file_path=nil)
      raise ShellError, 'No project is selected' if !@shell.project_name

      if !@shell.cwd && !file_path
        neat_display(folders: bucket_names)
        return
      end

      folder = @shell.client.list_folder(@shell.project_name, @shell.relative_path(file_path))

      neat_display(
        folders: folder[:folders].map{|f| f[:folder_name] },
        files: folder[:files].map{|f| f[:file_name]}
      )
    end

    def bucket_names
      @bucket_names ||= @shell.client.list_buckets(@shell.project_name).map{|b| b[:bucket_name]}
    end
  end

  class Ls < Command
    def run(file_path=nil)
      raise ShellError, 'No project is selected' if !@shell.project_name

      if !@shell.cwd && !file_path
        neat_display(folders: bucket_names)
        return
      end

      folder = @shell.client.list_folder(@shell.project_name, @shell.relative_path(file_path))

      neat_display(
        folders: folder[:folders].map{|f| f[:folder_name] },
        files: folder[:files].map{|f| f[:file_name]}
      )
    end

    def bucket_names
      @bucket_names ||= @shell.client.list_buckets(@shell.project_name).map{|b| b[:bucket_name]}
    end
  end

  class Project < Command
    def run(project_name=nil)
      raise ShellError, "No such project#{project_name && " '#{project_name}'" }. Try:\n#{@shell.project_list.join("\t")}" unless @shell.project_list.include?(project_name)

      @shell.project_name = project_name
      @cwd = nil
      @bucket_names = nil
    end

  end

  class Cd < Command
    def run(dirname=nil)
      if !dirname
        @shell.cwd = nil
        return
      end

      dirname.sub!(%r!/$!,'')

      path = @shell.relative_path(dirname)

      folder = @shell.client.list_folder(@shell.project_name, path)

      raise ShellError, "No such folder #{dirname}" unless folder

      @shell.cwd = path
    end
  end

  class Put < Command
    def run(*input_files)
      raise ShellError, 'No remote folder selected!' unless @shell.cwd

      # get a listing of the folder
      folder = @shell.client.list_folder(@shell.project_name, @shell.cwd)

      input_files.each do |file_or_folder|
        upload(file_or_folder, @shell.cwd, folder)
      end
    end

    private

    def upload(file_or_folder, folder_path, folder)
      if ::File.directory?(file_or_folder)
        upload_folder(file_or_folder, folder_path, folder)
      end
      if ::File.file?(file_or_folder)
        upload_file(file_or_folder, folder_path, folder)
      end
    end

    def upload_folder(input_folder, folder_path, folder)
      actual_path = ::File.expand_path(input_folder)
      folder_name = ::File.basename(actual_path)
      new_folder_path = ::File.join(folder_path, folder_name).sub(%r!^/!,'')

      # see if it exists
      existing_folder = folder[:folders].find do |f|
        f[:folder_name] == folder_name
      end

      if existing_folder
        new_folder = @shell.client.list_folder(@shell.project_name, new_folder_path)
      else
        @shell.client.create_folder(@shell.project_name, new_folder_path)
        new_folder = { folders: [], files: [] }
      end

      Dir["#{actual_path}/*"].each do |file_or_folder|
        upload(file_or_folder, new_folder_path, new_folder)
      end
    end

    def upload_file(input_file, folder_path, folder)
      # We go through the full upload cycle. First, authorize the upload
      actual_path = ::File.expand_path(input_file)
      file_name = ::File.basename(actual_path)
      bucket_name, new_folder_path = folder_path.split('/',2)
      new_file_path = ::File.join(*[new_folder_path, file_name].compact)

      # see if it exists
      return if folder[:files].find do |f|
        f[:file_name] == file_name && f[:size] == ::File.size(actual_path)
      end

      upload_json = @shell.client.authorize_upload(@shell.project_name, bucket_name, new_file_path)

      upload_path = upload_json[:url].sub(%r!^https://[^/]*?/!, '/')

      upload = Upload.new(actual_path)


      upload_json = @shell.client.start_upload(upload_path, upload)
      # start our upload

      upload.current_byte_position = upload_json[:current_byte_position].to_i
      upload.next_blob_size = upload_json[:next_blob_size].to_i

      # upload bytes until we are done

      if upload.complete?
        @shell.client.blob_upload(upload_path, upload,
          blob_data: '',
          next_blob_size: 0,
          next_blob_hash: ZERO_HASH,
          current_byte_position: upload.current_byte_position
        )

        puts progress(1, 0, new_file_path)
        return
      end

      start = Time.now
      while !upload.complete?

        blob_data = upload.current_bytes
        current_byte_position = upload.current_byte_position

        upload.next_blob!

        @shell.client.blob_upload(upload_path, upload,
          blob_data: blob_data,
          next_blob_size: upload.next_blob_size,
          next_blob_hash: upload.next_blob_hash,
          current_byte_position: current_byte_position
        )

        print progress(
          upload.current_byte_position.to_f / upload.file_size,
          (upload.current_byte_position / (Time.now - start).to_f).round(2),
          new_file_path
        )
      end
      puts
    end

    def progress(completion, rate, path)
      bar_size = 20

      progress = "+"*(bar_size * completion) + " "*(bar_size-completion)

      if rate > 1024*1024*1024
        rate = "#{(rate / 1024/1024/1024).round(2)}G"
      elsif rate > 1024*1024
        rate = "#{(rate / 1024/1024).round(2)}M"
      elsif rate > 1024
        rate = "#{(rate / 1024).round(2)}k"
      end

      "\r#{progress} #{path} - #{rate}B/s"
    end
  end

  class ShellError < StandardError
  end

  METIS_PATH=%r!
    ^metis:/(?<path>/.*)?$
  !x

  def initialize(path, *args)
    @token = ENV['TOKEN']

    raise 'No environment variable TOKEN is set' if !@token

    match = METIS_PATH.match(path)

    @host = MetisConfig[:metis_host]

    @args = args

    raise "No metis host selected\n#{USAGE}" if !@host

    if match&.[](:path)
      set_path(match[:path])
    end
  end
  attr_reader :project_name
  attr_accessor :cwd

  def project_name=(new_project)
    @project_name = new_project
    @cwd = nil
  end

  def set_path(path)
    @project_name, *folder_path = path.split(%r!/!).compact.reject(&:empty?)

    return unless @project_name

    unless project_list.include?(@project_name)
      puts "No such project '#{@project_name}'"
      @project_name = nil
    end

    return unless folder_path && !folder_path.empty?

    if path = folder_path.join("/")
      begin
        client.list_folder(@project_name, path)
        @cwd = path
      rescue MetisClient::Error
        puts "No such folder '#{path}'"
        @cwd = nil
      end
    end
  end

  def prompt
    "#{@project_name && "#{@project_name}:#{@cwd}"}> "
  end

  def complete(string)
    return project_list.grep(/^#{Regexp.escape(string)}/) unless @project_name

    if string[-1] == '/'
      dirname = string[0...-1]
      basename = ''
    else
      basename, dirname = string.split(%r!/(?=[^/]*$)!).reverse
    end

    begin
      path = Shellwords.split(relative_path(dirname) || '').first
      folder = client.list_folder(@project_name, path)
      return [] unless folder && folder.is_a?(Hash)
      [
        folder[:folders]&.map{|f| f[:folder_name]+"/"},
        folder[:files]&.map{|f| f[:file_name]+" "}
      ]
        .flatten.compact
        .grep(/^#{Regexp.escape(basename||'')}/)
        .map{|s| [dirname, s].compact.join('/').gsub(/(?<!\\) (?!$)/, '\ ')}
    rescue MetisClient::Error
      []
    end
  end

  def run
    unless @args.empty?
      command, *args = @args
      run_command(command, *args)
      return
    end

    Readline.completion_proc = proc do |string|
      complete(string)
    end
    Readline.completer_quote_characters = "\"'"
    Readline.completion_append_character = nil
    Readline.basic_word_break_characters = " \t\n\"'`@$><=;|&{("
    Readline.quoting_detection_proc = proc do |input, index|
      (index > 0 &&
        input[index] == ' ' &&
        input[index-1] == '\\' &&
        (index == 1 || input[index-2] != '\\')) ||
      ((index + 1 < input.size) && input[index] == '\\' && input[index+1] == ' ' && (index == 0 || input[index-1] != '\\'))
    end

    while buf = Readline.readline(prompt, true)
      run_command(*parse(buf))
    end
  end

  def client
    @client ||= MetisClient.new(@host, @token)
  end

  def relative_path(file_path=nil)
    path = file_path ? Pathname.new(::File.join(*[@cwd, file_path].compact)).cleanpath.to_s : @cwd
    path =~ /^\./ ? nil : path
  end

  def project_list
    @project_list ||= begin
      JSON.parse(
        Base64.decode64(@token.split(/\./)[test_env? ? 0 : 1])
      )["perm"].split(/;/).map{|l| l.split(/:/).last.split(/,/) }.flatten
    rescue
      puts "Could not parse token"
      []
    end
  end

  private

  def run_command(command=nil, *args)
    return if !command
    command = Command.list.find { |c| c.command_name == command.to_s }

    unless command
      puts "Invalid command. Try:\n#{Command.list.map(&:command_name).join("\t")}"
      return
    end

    begin
      command.new(self).run(*args)
    rescue ShellError => e
      puts e.message
    rescue MetisClient::Error => e
      puts e.message
    rescue ArgumentError => e
      puts e.message
    rescue Net::ReadTimeout => e
      puts e.message
    end
  end

  VALID_INPUT=/^(?<command>\w+)(?:\s+(?<args>.*))?$/

  def parse(line)
    input = VALID_INPUT.match(line)

    return nil unless input
    return [
      input[:command],
      *Shellwords.split(input[:args] || '')
    ]
  end
end

unless test_env?
  if ::File.exists?(CONFIG_FILE)
    config = JSON.parse(File.read(CONFIG_FILE), symbolize_names: true)
  else
    puts "Could not find configuration at #{CONFIG_FILE}, please run `metis_client setup`"
    exit

    @config = {
      metis_uid: SecureRandom.hex,
      metis_uid_name: 'METIS_UID'
    }
    ::File.write(filename,JSON.pretty_generate(@config))
  end

  MetisConfig.instance.config(config)
  MetisShell.new(ARGV[0], *ARGV[1..-1]).run
  puts
end
